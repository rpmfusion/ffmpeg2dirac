diff -up ffmpeg2dirac-0.2.0/src/avinfo.c.ffmpeg ffmpeg2dirac-0.2.0/src/avinfo.c
--- ffmpeg2dirac-0.2.0/src/avinfo.c.ffmpeg	2011-04-25 03:30:42.000000000 +0200
+++ ffmpeg2dirac-0.2.0/src/avinfo.c	2011-09-09 19:06:24.000000000 +0200
@@ -198,7 +198,11 @@ void json_codec_info(FILE *output, AVCod
     }
 
     switch(enc->codec_type) {
+#if LIBAVCODEC_VERSION_MAJOR < 53
     case CODEC_TYPE_VIDEO:
+#else
+    case AVMEDIA_TYPE_VIDEO:
+#endif
         codec_name = fix_codec_name(codec_name);
         json_add_key_value(output, "codec", (void *)codec_name, JSON_STRING, 0, indent);
         if (enc->pix_fmt != PIX_FMT_NONE) {
@@ -226,7 +230,11 @@ void json_codec_info(FILE *output, AVCod
             json_add_key_value(output, "bitrate", &t, JSON_FLOAT, 0, indent);
         }
         break;
+#if LIBAVCODEC_VERSION_MAJOR < 53
     case CODEC_TYPE_AUDIO:
+#else
+    case AVMEDIA_TYPE_AUDIO:
+#endif
         codec_name = fix_codec_name(codec_name);
         json_add_key_value(output, "codec", (void *)codec_name, JSON_STRING, 0, indent);
         if (enc->sample_rate) {
@@ -332,7 +340,11 @@ static void json_stream_format(FILE *out
                      display_aspect_ratio.num, display_aspect_ratio.den);
             json_add_key_value(output, "display_aspect_ratio", buf1, JSON_STRING, 0, indent + 1);
         }
+#if LIBAVCODEC_VERSION_MAJOR < 53
         if(st->codec->codec_type == CODEC_TYPE_VIDEO){
+#else
+        if(st->codec->codec_type == AVMEDIA_TYPE_VIDEO){
+#endif
             if (st->time_base.den && st->time_base.num && av_q2d(st->time_base) > 0.001) {
                 snprintf(buf1, sizeof(buf1), "%d:%d",
                          st->time_base.den, st->time_base.num);
@@ -486,11 +498,19 @@ void json_format_info(FILE* output, AVFo
             int j, k;
             for(j=0; j<ic->nb_programs; j++) {
                 for(k=0; k<ic->programs[j]->nb_stream_indexes; k++)
+#if LIBAVCODEC_VERSION_MAJOR < 53
                     json_stream_format(output, ic, ic->programs[j]->stream_index[k], 2, !k && !j, CODEC_TYPE_VIDEO);
+#else
+                    json_stream_format(output, ic, ic->programs[j]->stream_index[k], 2, !k && !j, AVMEDIA_TYPE_VIDEO);
+#endif
              }
         } else {
             for(i=0;i<ic->nb_streams;i++) {
+#if LIBAVCODEC_VERSION_MAJOR < 53
                 json_stream_format(output, ic, i, 2, !i, CODEC_TYPE_VIDEO);
+#else
+                json_stream_format(output, ic, i, 2, !i, AVMEDIA_TYPE_VIDEO);
+#endif
             }
         }
         fprintf(output, "],\n");
@@ -501,11 +521,19 @@ void json_format_info(FILE* output, AVFo
             int j, k;
             for(j=0; j<ic->nb_programs; j++) {
                 for(k=0; k<ic->programs[j]->nb_stream_indexes; k++)
+#if LIBAVCODEC_VERSION_MAJOR < 53
                     json_stream_format(output, ic, ic->programs[j]->stream_index[k], 2, !k && !j, CODEC_TYPE_AUDIO);
+#else
+                    json_stream_format(output, ic, ic->programs[j]->stream_index[k], 2, !k && !j, AVMEDIA_TYPE_AUDIO);
+#endif
              }
         } else {
             for(i=0;i<ic->nb_streams;i++) {
+#if LIBAVCODEC_VERSION_MAJOR < 53
                 json_stream_format(output, ic, i, 2, !i, CODEC_TYPE_AUDIO);
+#else
+                json_stream_format(output, ic, i, 2, !i, AVMEDIA_TYPE_AUDIO);
+#endif
             }
         }
         fprintf(output, "],\n");
diff -up ffmpeg2dirac-0.2.0/src/ffmpeg2dirac.c.ffmpeg ffmpeg2dirac-0.2.0/src/ffmpeg2dirac.c
--- ffmpeg2dirac-0.2.0/src/ffmpeg2dirac.c.ffmpeg	2011-04-25 03:30:42.000000000 +0200
+++ ffmpeg2dirac-0.2.0/src/ffmpeg2dirac.c	2011-09-09 19:18:04.000000000 +0200
@@ -379,7 +379,11 @@ static void prepare_frame_buffer(ff2dira
 static const char *find_category_for_subtitle_stream (ff2dirac this, int idx, int included_subtitles)
 {
   AVCodecContext *enc = this->context->streams[idx]->codec;
+#if LIBAVCODEC_VERSION_MAJOR < 53
   if (enc->codec_type != CODEC_TYPE_SUBTITLE) return 0;
+#else
+  if (enc->codec_type != AVMEDIA_TYPE_SUBTITLE) return 0;
+#endif
   switch (enc->codec_id) {
     case CODEC_ID_TEXT:
     case CODEC_ID_SSA:
@@ -538,9 +542,16 @@ static void extra_info_from_ssa(AVPacket
 
 static const char *find_language_for_subtitle_stream(const AVStream *s)
 {
+#if FF_API_OLD_METADATA
   const char *lang=find_iso639_1(s->language);
   if (!lang) {
     fprintf(stderr,"WARNING - unrecognized ISO 639-2 language code: %s\n",s->language);
+#else
+  AVDictionaryEntry *entry=av_metadata_get(s->metadata,"language",NULL,0);
+  const char *lang=find_iso639_1(entry->value);
+  if (!lang) {
+    fprintf(stderr,"WARNING - unrecognized ISO 639-2 language code: %s\n",entry->value);
+#endif
   }
   return lang;
 }
@@ -568,7 +579,11 @@ void ff2dirac_output(ff2dirac this) {
 
     if(this->audiostream >= 0 && this->context->nb_streams > this->audiostream) {
         AVCodecContext *enc = this->context->streams[this->audiostream]->codec;
+#if LIBAVCODEC_VERSION_MAJOR < 53
         if (enc->codec_type == CODEC_TYPE_AUDIO) {
+#else
+        if (enc->codec_type == AVMEDIA_TYPE_AUDIO) {
+#endif
             this->audio_index = this->audiostream;
             fprintf(stderr,"  Using stream #0.%d as audio input\n",this->audio_index);
         }
@@ -579,7 +594,11 @@ void ff2dirac_output(ff2dirac this) {
 
     if (this->videostream >= 0 && this->context->nb_streams > this->videostream) {
         AVCodecContext *enc = this->context->streams[this->videostream]->codec;
+#if LIBAVCODEC_VERSION_MAJOR < 53
         if (enc->codec_type == CODEC_TYPE_VIDEO) {
+#else
+        if (enc->codec_type == AVMEDIA_TYPE_VIDEO) {
+#endif
             this->video_index = this->videostream;
             fprintf(stderr, "  Using stream #0.%d as video input\n",this->video_index);
         }
@@ -591,11 +610,19 @@ void ff2dirac_output(ff2dirac this) {
     for (i = 0; i < this->context->nb_streams; i++){
         AVCodecContext *enc = this->context->streams[i]->codec;
         switch (enc->codec_type){
+#if LIBAVCODEC_VERSION_MAJOR < 53
             case CODEC_TYPE_VIDEO:
+#else
+            case AVMEDIA_TYPE_VIDEO:
+#endif
               if (this->video_index < 0 && !this->disable_video)
                     this->video_index = i;
                 break;
+#if LIBAVCODEC_VERSION_MAJOR < 53
             case CODEC_TYPE_AUDIO:
+#else
+            case AVMEDIA_TYPE_AUDIO:
+#endif
                 if (this->audio_index < 0 && !this->disable_audio)
                     this->audio_index = i;
                 break;
@@ -1024,7 +1051,11 @@ void ff2dirac_output(ff2dirac this) {
           AVStream *stream = this->context->streams[i];
           AVCodecContext *enc = stream->codec;
           const char *category;
+#if LIBAVCODEC_VERSION_MAJOR < 53
           if (enc->codec_type == CODEC_TYPE_SUBTITLE) {
+#else
+          if (enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {
+#endif
             AVCodec *codec = avcodec_find_decoder (enc->codec_id);
             if (codec && avcodec_open (enc, codec) >= 0) {
               subtitles_opened[i] = 1;
@@ -2924,7 +2955,9 @@ int main (int argc, char **argv){
             formatParams->time_base.den = convert->framerate.num;
             formatParams->time_base.num = convert->framerate.den;
         }
+#if FF_API_PARAMETERS_CODEC_ID
         formatParams->video_codec_id = av_guess_image2_codec(inputfile_name);
+#endif
     }
     if (av_open_input_file(&convert->context, inputfile_name, input_fmt, 0, formatParams) >= 0){
         if (av_find_stream_info (convert->context) >= 0){
@@ -2936,9 +2969,15 @@ int main (int argc, char **argv){
                 for (i = 0; i < convert->context->nb_streams; i++) {
                     AVCodecContext *enc = convert->context->streams[i]->codec;
                     switch (enc->codec_type) {
+#if LIBAVCODEC_VERSION_MAJOR < 53
                         case CODEC_TYPE_VIDEO: has_video = 1; break;
                         case CODEC_TYPE_AUDIO: has_audio = 1; break;
                         case CODEC_TYPE_SUBTITLE: if (is_supported_subtitle_stream(convert, i, convert->included_subtitles)) has_kate = 1; break;
+#else
+                        case AVMEDIA_TYPE_VIDEO: has_video = 1; break;
+                        case AVMEDIA_TYPE_AUDIO: has_audio = 1; break;
+                        case AVMEDIA_TYPE_SUBTITLE: if (is_supported_subtitle_stream(convert, i, convert->included_subtitles)) has_kate = 1; break;
+#endif
                         default: break;
                     }
                 }
